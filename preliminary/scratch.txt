Look at the ball program mentioned in the paper. When a mouse event happens, . While

The original motivation is to create an class that is compatible to both GameItem and Thread. This class should be able to do GameItem related operations while being runnable in a thread. The Twin pattern achieves this by creating two classes interacting to each other as follows: when a mouse event, the BallItem class, which subclasses from GameItem, updates its internal flag, then resumes or suspends its companion, the BallThread class, which subclasses from Thread, to resume or suspend drawing its graphics. While it achieves the goals, there are other angles to look at this problem without multiple inheritance. First, fron a structural standpoint, the BallItem is a GameItem that has Runnable behavior (the shared behavior of Thread). In this case, BallItem could inherit only from GameItem but encapsulates a Thread (or a Runnable) object. This is where Factory, Strategy, and Composite patterns are applicable. For example, using Composite, a new class could be created that composes a separate BallItem and Thread object and let them interact inside the class without coupling them to their internal state. Second, from a behavior standpoint, the BallItem updates a state then signals the appropriate action of the BallThread class. This is where Observer and Mediator are applicable. For example, using these patterns, an intermediate class or a publish/subscribe mechanism can be created to process the communication between BallItem or Thread.

It is not too difficult to implement the ball program using Twin pattern in Scala, as Scala is object-oriented, just like Java. Most of the code can be translated directly from Java to Scala, except for minor modifications regarding syntax or function calls. The same applies for Mediator pattern. However, notice that the participating classes are aware of the mediator. This fact could be considered a drawback since if Mediator pattern is replaced by a different one, the participating classes have to be rewritten to remove the pattern and accomodate for the new one. There is, however, a different way to implement Mediator without making these classes coupled to the pattern. The method is to use protected anonymous trait inside the mediator that handles intercommunication between participating class. The mediator then handles constructing participating classes, mixing in this trait on the fly, and returning new improved participating classes without actually modifying their class implementation.
